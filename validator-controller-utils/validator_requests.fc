(int) subtract_standart_fee(int msg_value, int id) inline {
  msg_value =  msg_value - fees::elector() - fees::stake_operation() - fees::receipt();
  throw_unless(err::insufficient_fee(id), msg_value >= 0);
  return msg_value;
}

() send_new_stake (int msg_value, int query_id, tuple storage, slice s_addr, slice in_msg) impure {
  msg_value = subtract_standart_fee(msg_value, 1);
  int amount = in_msg~load_grams();
  slice cs = in_msg;
  ;; Stake checks borrowed from https://github.com/newton-blockchain/ton/blob/master/crypto/smartcont/elector-code.fc#L208
  (int pool_wc, int pool_addr) = parse_std_addr(my_address());
  var validator_pubkey = cs~load_uint(256);
  var stake_at = cs~load_uint(32);
  var max_factor = cs~load_uint(32);
  var adnl_addr = cs~load_uint(256);
  var signature = cs~load_ref().begin_parse().preload_bits(512);
  cs.end_parse();
  ifnot (check_data_signature(begin_cell()
      .store_uint(0x654c5074, 32)
      .store_uint(stake_at, 32)
      .store_uint(max_factor, 32)
      .store_uint(pool_addr, 256)
      .store_uint(adnl_addr, 256)
    .end_cell().begin_parse(), signature, validator_pubkey)) {
    ;; incorrect signature
    return send_receipt_message(s_addr, 0xee6f454c, query_id, 1, 0, 0, 64);
  }
  if (max_factor < 0x10000) {
    ;; factor must be >= 1. = 65536/65536
    return send_receipt_message(s_addr, 0xee6f454c, query_id, 6, 0, 0, 64);
  }
  ;; All checks we can make locally
  
  (slice _1, slice _2,
   int val_balance, int nom_balance, 
   int val_req, int nom_req, 
   int _7, 
   int validator_cover_ability,
   cell front1, cell front2) = storage_untuple(storage);
  (slice front_addr, int last_stake_request, int stake_on_elector, slice on_fly_query, int proxy_id, int chosen?) = choose_proxy(front1, front2);
  throw_unless(err::no_suitable_proxy(), chosen?);
  throw_if(err::unprocessed_withdrawal_requests(), val_req | nom_req);
  throw_unless(err::validation_amount_too_high(), amount <= val_balance + nom_balance);
  throw_if(err::cover_ability_violation(), 
               max_recommended_punishment_for_validator_misbehaviour(amount) * validator_cover_ability >> 16
                > 
               val_balance);

  int op = op::elector::request::stake();
  int elector_query_id = new_query_id();

  send_through_proxy(
               front_addr,
               amount,
               begin_cell()
                           .store_uint(op, 32)
                           .store_uint(elector_query_id, 64)
                           .store_slice(in_msg)
               .end_cell());
  builder qry = serialize_query(op, now(), query_id, msg_value, s_addr);
  last_stake_request = now(); ;; write time immediately, remove on error on elector side
  stake_on_elector += amount;
  (front1, front2)~update_proxies(front_addr, last_stake_request, stake_on_elector, qry, proxy_id);
  save_data(_1, _2, val_balance, nom_balance, val_req, nom_req, _7, validator_cover_ability, front1, front2);
}

() recover_stake (int msg_value, int query_id, tuple storage, slice s_addr) impure {
  msg_value = subtract_standart_fee(msg_value, 2);
  int elector_query_id = new_query_id();
  int op = 0x47657424;
  (slice _1, slice _2, int _3, int _4, int _5, int _6, int _7, int _8,
   cell front1, cell front2) = storage_untuple(storage);
  (slice front_addr, int last_stake_request, int stake_on_elector, slice on_fly_query, int proxy_id, int chosen?) = choose_proxy(front1, front2);
  throw_unless(err::no_suitable_proxy(), chosen?);
  send_through_proxy(front_addr,
               fees::elector(),
               begin_cell()
                           .store_uint(op, 32)
                           .store_uint(elector_query_id, 64)
               .end_cell() );
  builder qry = serialize_query(op, now(), query_id, msg_value, s_addr);
  (front1, front2)~update_proxies(front_addr, last_stake_request, stake_on_elector, qry, proxy_id);
  save_data(_1, _2, _3, _4, _5, _6, _7, _8, front1, front2);
}

;; It is withdrawal of funds which formally is not owned by anybody
() validator_withdraw (slice in_msg, int msg_value, int query_id, tuple storage, slice s_addr) impure {
  msg_value = subtract_standart_fee(msg_value, 3);
  (slice _1, slice _2,
   int val_balance, int nom_balance, 
   int val_req, int nom_req, 
   int _7, 
   int _8,
   cell _9, 
   cell _10) = storage_untuple(storage);
  int amount = in_msg~load_grams();
  int op = 0x006e7bac;
  throw_if(416, val_req | nom_req); 
  raw_reserve(val_balance + nom_balance, 0);
  raw_reserve(fees::storage_reserve(), 0); ;; Save at least 10 Toncoins for storage fees
  return send_receipt_message(s_addr, op | 0x80000000, query_id, 0, 0, amount, 1);
}


;; returns true if found and processed validator request
(int) process_validator_request (slice in_msg, int msg_value, tuple storage, slice s_addr) impure {
  if (in_msg.slice_empty?()) {
    return false;
  }
  int op = in_msg~load_uint(32);
  if ( op == 0 ) { ;; op==0 - comment interface is not available for validator
    return false;
  }
  int query_id = in_msg~load_uint(64);

  if (op == 0x4e73744b) {
    ;; new stake message
    send_new_stake(msg_value, query_id, storage, s_addr, in_msg);
    return true;
  }
  if (op == 0x47657424) {
    ;; recover stake request
    recover_stake(msg_value, query_id, storage, s_addr); ;;(op, s_addr, in_msg, query_id);
    return true;
  }
  if (op == 0x006e7bac) {
    validator_withdraw(in_msg, msg_value, query_id, storage, s_addr);
    return true;
  }
  return false;
}
