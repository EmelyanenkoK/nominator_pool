;; TLB Storage scheme
;; Note address bits in pseudoaddress is sum of address and workchain,
;; chances of collision and overflow are negligible. -1:00..000 has no ability to
;; stake in pool
;;
;; participant_data#_ address:MsgAddressInt balance:Grams requested_amount:Grams = Participant;
;; empty_query#0 = Query;
;; query#1 op:uint32 time:uint32 response_id:uint64 amount:Grams s_addr:MsgAddressInt = Query;
;; front#_ address:MsgAddressInto
;;         last_stake_sent:uint32 stake_on_elector:Grams on_fly_query:Query = Front;

;; storage#_ 
;;           validator:^Participant
;;           nominator:^Participant
;;           validator_reward_share:uint16
;;           validator_cover_ability:uint16
;;           front1: ^Front
;;           front2: ^Front
;;           = Storage;

(slice, slice, int, int, int, int, int, int, cell, cell) load_data () inline {
  var ds = get_data().begin_parse();
  slice v_participant = ds~load_ref().begin_parse();
  slice n_participant = ds~load_ref().begin_parse();
  return (
          v_participant~load_msg_addr(),
          n_participant~load_msg_addr(),
          v_participant~load_grams(),
          n_participant~load_grams(),
          v_participant~load_grams(),
          n_participant~load_grams(),
          ds~load_uint(16),
          ds~load_uint(16),
          ds~load_ref(),
          ds~load_ref()
          );
}

() save_data (
              slice validator,
              slice nominator,
              int validator_balance,
              int nominator_balance,
              int validator_requested_withdrawal,
              int nominator_requested_withdrawal,
              int validator_reward_share,
              int validator_cover_ability,
              cell front1, cell front2) impure inline {
  cell v_participant = begin_cell().store_slice(validator)
                                   .store_grams(validator_balance)
                                   .store_grams(validator_requested_withdrawal)
                       .end_cell();
  cell n_participant = begin_cell().store_slice(nominator)
                                   .store_grams(nominator_balance)
                                   .store_grams(nominator_requested_withdrawal)
                       .end_cell();
  var st = begin_cell().store_ref(v_participant)
                       .store_ref(n_participant)
                       .store_uint(validator_reward_share, 16)
                       .store_uint(validator_cover_ability, 16)
                       .store_ref(front1)
                       .store_ref(front2)
            .end_cell();
  set_data(st);
}

(int, int, int, int, slice) deserialize_query (slice query) {
  if(query~load_int(1)) {
    return (query~load_uint(32), query~load_uint(32),
            query~load_uint(64), query~load_grams(),
            query);
  } else {
    return (0, 0, 0, 0, null());
  }
}

builder empty_query() inline {
  return begin_cell().store_int(0, 1);
}
builder serialize_query(int op, int time, int query_id, int amount, slice address) inline {
   return begin_cell().store_int(-1, 1).store_uint(op, 32).store_uint(time, 32)
                      .store_uint(query_id, 64).store_grams(amount).store_slice(address);
}

(slice, int, int, slice) deserialize_front (cell front) {
  slice fs =  front.begin_parse();
  return (fs~load_msg_addr(),
          fs~load_uint(32),
          fs~load_grams(),
          fs);
}

cell serialize_front(slice addr, int last_stake_sent, int stake_on_elector, builder query) {
  return begin_cell().store_slice(addr)
                     .store_uint(last_stake_sent,32)
                     .store_grams(stake_on_elector)
                     .store_builder(query)
         .end_cell();                        
}

int is_init() inline {
  return get_data().begin_parse().slice_refs() == 2;
}

() init_fronts(slice addr1, slice addr2) impure {
  slice ds = get_data().begin_parse();
  set_data( begin_cell()
              .store_slice(ds)
              .store_ref(serialize_front(addr1, 0, 0, empty_query()))
              .store_ref(serialize_front(addr2, 0, 0, empty_query()))
            .end_cell()
  );
}
